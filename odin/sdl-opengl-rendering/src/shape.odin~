package visuals

import "core:log"
import "core:math/linalg"
import "vendor:OpenGL"


// {{{ Shape Types
Shape :: struct {
	z:    ℝ,
	fill: Color,
}

Rect :: struct {
	using shape: Shape,
	top_left:    ℝ²,
	dimensions:  ℝ²,
}

Circle :: struct {
	using shape: Shape,
	center:      ℝ²,
	radius:      ℝ,
}

Line :: struct {
	using shape: Shape,
	from:        ℝ²,
	to:          ℝ²,
	thickness:   ℝ,
}

Rounded_Line :: distinct Line
// }}}
// {{{ Command queues
Command_Queue :: struct {
	rects:         [dynamic]Rect,
	circles:       [dynamic]Circle,
	lines:         [dynamic]Line,
	rounded_lines: [dynamic]Rounded_Line,
}

queue: ^Command_Queue

init_command_queue :: proc() {
	queue = new(Command_Queue)
	queue^ = Command_Queue {
		rects         = make([dynamic]Rect),
		circles       = make([dynamic]Circle),
		lines         = make([dynamic]Line),
		rounded_lines = make([dynamic]Rounded_Line),
	}
}

draw_rect_args :: proc(top_left: ℝ², dimensions: ℝ², color: Color, z: ℝ = 0) {
	draw_rect_struct(
		Rect{top_left = top_left, dimensions = dimensions, shape = Shape{z = z, fill = color}},
	)
}

draw_rect_struct :: proc(rect: Rect) {
	append(&queue.rects, rect)
}

draw_rect :: proc {
	draw_rect_struct,
	draw_rect_args,
}

draw_circle_args :: proc(center: ℝ², radius: ℝ, color: Color, z: ℝ = 0) {
	draw_circle_struct(
		Circle{center = center, radius = radius, shape = Shape{z = z, fill = color}},
	)
}

draw_circle_struct :: proc(circle: Circle) {
	append(&queue.circles, circle)
}

draw_circle :: proc {
	draw_circle_struct,
	draw_circle_args,
}

draw_line_args :: proc(from, to: ℝ², thickness: ℝ, color: Color, z: ℝ = 0) {
	draw_line_struct(
		Line{from = from, to = to, thickness = thickness, shape = Shape{z = z, fill = color}},
	)
}

draw_line_struct :: proc(line: Line) {
	append(&queue.lines, line)
}

draw_line :: proc {
	draw_line_struct,
	draw_line_args,
}

draw_rounded_line_args :: proc(from, to: ℝ², thickness: ℝ, color: Color, z: ℝ = 0) {
	draw_rounded_line_struct(
		Line{from = from, to = to, thickness = thickness, shape = Shape{z = z, fill = color}},
	)
}

draw_rounded_line_struct :: proc(line: $T/Line) {
	append(&queue.rounded_lines, Rounded_Line(line))
}

draw_rounded_line :: proc {
	draw_rounded_line_struct,
	draw_rounded_line_args,
}
// }}}
// {{{ Shape -> Transform
to_transform_rect :: proc(rect: Rect) -> (mat: Mat3) {
	center := rect.top_left + rect.dimensions / 2
	mat[0, 0] = rect.dimensions.x / 2
	mat[1, 1] = rect.dimensions.y / 2
	mat[2, 2] = 1
	mat[2].xy = center.xy
	return mat
}

to_transform_circle :: proc(circle: Circle) -> (mat: Mat3) {
	mat[0, 0] = circle.radius
	mat[1, 1] = circle.radius
	mat[2, 2] = 1
	mat[2].xy = circle.center.xy
	return mat
}

to_transform_line :: proc(line: Line) -> (mat: Mat3) {
	dir := line.to - line.from
	mat[0].xy = dir / 2
	mat[1].xy = vec2_perp(linalg.normalize0(dir)) * line.thickness
	mat[2].xy = (line.from + line.to) / 2
	mat[2].z = line.z
	return mat
}

to_transform_rounded_line :: proc(line: Rounded_Line) -> (mat: Mat3) {
	dir := line.to - line.from
	mat[0].xy = dir / 2
	mat[1].xy = vec2_perp(linalg.normalize0(dir)) * line.thickness
	mat[2].xy = (line.from + line.to) / 2
	mat[2].z = line.z
	mat[0, 0] /= 2
	mat[0, 1] /= 2
	return mat
}

// This matrix must transform [-1, 1]² into the desired rect
to_transform :: proc {
	to_transform_rect,
	to_transform_circle,
	to_transform_line,
	to_transform_rounded_line,
}
// }}}

// {{{ GPU data types
VAO :: struct {
	vao:                  u32,
	vertex_ind_buffer:    u32,
	vertex_pos_buffer:    u32,
	instance_fill_buffer: u32,
	instance_mat_buffer:  u32,
	index_count:          ℕ,
}


// odinfmt: disable
RMat3 ::   matrix[4, 4]f32
// odinfmt: enable

UBO :: u32
Global_Uniforms :: struct {
	viewport_matrix: RMat3,
	aaWidth:         f32,
}

Program :: u32

INSTANCES :: 1024 // The number of instances to allocate space in the buffer for
VERTEX_POS_LOCATION :: 0
INSTANCE_FILL_LOCATION :: 1
INSTANCE_MAT_LOCATION :: 2
GLOBALS_UBO_BINDING :: 0
// }}}
// {{{ Create globals UBO
create_globals_ubo :: proc() -> UBO {
	id := gen_buffer()

	set_buffer(id, &Global_Uniforms{}, buffer = .Uniform)
	OpenGL.BindBufferBase(OpenGL.UNIFORM_BUFFER, GLOBALS_UBO_BINDING, id)

	return id
}
// }}}
// {{{ Create VAO
create_vao :: proc(vertices: []ℝ², indices: []u32) -> (out: VAO, ok: bool) {
	out.index_count = len(indices)

	// Create VAO
	OpenGL.GenVertexArrays(1, &out.vao)
	OpenGL.BindVertexArray(out.vao)
	defer OpenGL.BindVertexArray(0)

	// Create instance fill VBO
	out.instance_fill_buffer = gen_buffer()
	bind_buffer(out.instance_fill_buffer, .Array)

	OpenGL.EnableVertexAttribArray(INSTANCE_FILL_LOCATION)
	OpenGL.VertexAttribPointer(INSTANCE_FILL_LOCATION, 4, OpenGL.FLOAT, false, size_of(Color), 0)
	OpenGL.VertexAttribDivisor(INSTANCE_FILL_LOCATION, 1)

	// Create instance mat VBO
	out.instance_mat_buffer = gen_buffer()
	bind_buffer(out.instance_mat_buffer, .Array)

	setup_vbo(
		out.instance_mat_buffer,
		INSTANCE_MAT_LOCATION,
		ty = .Float,
		rows = 3,
		cols = 3,
		divisor = 1,
	)

	for i in u32(0) ..< 3 {
		OpenGL.EnableVertexAttribArray(INSTANCE_MAT_LOCATION + i)
		vec3_size :: size_of(ℝ³)
		OpenGL.VertexAttribPointer(
			INSTANCE_MAT_LOCATION + i,
			3,
			OpenGL.FLOAT,
			false,
			3 * vec3_size,
			uintptr(i * vec3_size),
		)
		OpenGL.VertexAttribDivisor(INSTANCE_MAT_LOCATION + i, 1)
	}

	// Create position VBO
	out.vertex_pos_buffer = gen_buffer()
	set_buffer(out.vertex_pos_buffer, vertices, usage = .Static)

	OpenGL.EnableVertexAttribArray(VERTEX_POS_LOCATION)
	OpenGL.VertexAttribPointer(VERTEX_POS_LOCATION, 2, OpenGL.FLOAT, false, 2 * size_of(ℝ), 0)

	// Create the vertex_ind_buffer
	out.vertex_ind_buffer = gen_buffer()
	set_buffer(out.vertex_ind_buffer, indices, buffer = .Element_Array, usage = .Static)

	return out, true
}
// }}}

// {{{ Render the entire queue
render_instanced :: proc(state: ^State, vao: VAO, shapes: ^[dynamic]$T) {
	OpenGL.BindVertexArray(vao.vao)

	steps := len(shapes) / INSTANCES

	for i := 0; i < len(shapes); i += INSTANCES {
		slice := shapes[i:]
		if len(slice) > INSTANCES {slice = slice[:INSTANCES]}

		for shape, i in shapes {
			state.buf_matrices[i] = to_transform(shape)
			state.buf_matrices[i][2, 2] = shape.z
			state.buf_colors[i] = shape.fill
		}

		set_buffer(vao.instance_mat_buffer, &state.buf_matrices)
		set_buffer(vao.instance_fill_buffer, &state.buf_colors)

		OpenGL.DrawElementsInstanced(
			OpenGL.TRIANGLE_FAN,
			i32(vao.index_count),
			OpenGL.UNSIGNED_INT,
			nil,
			i32(len(shapes)),
		)
	}

	clear(shapes)
}

render_queue :: proc(state: ^State) {
	// Update uniform data
	set_buffer(state.globals_ubo, &state.globals, buffer = .Uniform)

	// Toggle the wireframe
	OpenGL.PolygonMode(OpenGL.FRONT_AND_BACK, state.wireframe ? OpenGL.LINE : OpenGL.FILL)

	OpenGL.UseProgram(state.rect_program)
	render_instanced(state, state.rect_vao, &queue.rects)

	OpenGL.UseProgram(state.circle_program)
	render_instanced(state, state.rect_vao, &queue.circles)

	OpenGL.UseProgram(state.line_program)
	render_instanced(state, state.rect_vao, &queue.lines)

	OpenGL.UseProgram(state.rounded_line_program)
	render_instanced(state, state.rect_vao, &queue.rounded_lines)

	OpenGL.UseProgram(0)
}
// }}}
